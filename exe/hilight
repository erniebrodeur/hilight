#!/usr/bin/env ruby

require "hilight"
require 'term/ansicolor'
require 'open3'
require 'optparse'

include Hilight #rubocop:disable all

def split_opts(array)
  cmd_start_index = array.find_index { |e| !e.start_with? "-" }
  return [[], array] if !cmd_start_index || cmd_start_index.zero?

  [array[0..cmd_start_index - 1], array[cmd_start_index..-1] ]
end

Hilight::Filter = Struct.new(:cmd, :patterns)
Hilight::Filter.define_method(:match?) do |string|
  case cmd
  when (String || Symbol) then (cmd.to_s == string.to_s)
  when Regexp then (cmd.match? string.to_s)
  else false
  end
end

Hilight::Filters = Struct.new(:collection)
Hilight::Filters.define_method(:find) do |match|
  collection.find { |f| f.match? match } || collection.find { |e| e.cmd == 'default' }
end

Hilight::Filters.define_method(:exec) do |string|
  f = find string
  output, process = Open3.capture2e(string)
  puts f.patterns.transform(output)
  exit process.exitstatus
end

rspec = Fabric[[
  Pattern[/(?<green>\d+) examples, (?<red>\d+) failures?, (?<yellow>\d+) pending/, '\k<green> examples, \k<red> failures, \k<yellow> pending'],
  Pattern[/(?<blue>\d+\.\d+)/, '\k<blue>'],
  Pattern[/\"(?<green>.*?)\"|\'(?<green>.*?)\'/, '\k<green>'],
  Pattern[/# (?<red>.*):(?<yellow>\d+)/, '\k<red>:\k<yellow>']
]]

help = Fabric[[Pattern[/(?<yellow>\B-{1,2}[\w-]+)|(?<blue>[\[\]\(\)\{\}\<\>])|(?<green>["'].*?["'])/, '\k<yellow>\k<blue>\k<green>']]]
git = Fabric[[Pattern[/(?<green>'.*?')|(?<blue>".*?")/, '\k<green>\k<blue>']]]
ruby = Fabric[[Pattern[/(.*from |)(?<red>.*):(?<blue>\d+)(?::in )(?<yellow>`.*')/, '\k<red>\k<blue>\k<yellow>']]]
default = Fabric[[Pattern[/(?<green>\d+\.\d+)|(?<blue>".*")/, '\k<green>\k<blue>']]]

filters = Filters[[
  Filter["rspec", rspec],
  Filter[/-h|--help|help/, help],
  Filter["git", git],
  Filter["ruby", ruby],
  Filter["default", default]
]]

Fabric.define_method(:streaming_exec) do |cmd|
  Open3.popen3(cmd) do |_stdin, stdout, _stderr, thr|
    loop do
      sleep 0.001
      $stdout << transform(stdout.readpartial(stdout.nread))
      break unless thr.alive?
    end
  end
end

Hilight::Filters.define_method(:exec) do |string|
  f = find string
  output, process = Open3.capture2e(string)
  puts f.patterns.transform(output)
  exit process.exitstatus
end

options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: hilight <cmd>"

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
end

test_string = "one two three four five six seven"
test_pattern = Pattern[/(?<yellow>two)|(?<red>\w*o\w*)|(?<green>one)/, '']
# arguments, cmd = split_opts ARGV
# parser.parse arguments

Hilight::Pattern.define_method(:offsets) do |input|
  offsets = {}
  offsets['clear'] = []

  m = regexp.match input
  processed_characters = 0
  while m
    m.named_captures.each do |color, string|
      next unless string

      # offsets.push [m.begin(color) + processed_characters, m.end(color) + processed_characters, color]
      offsets[color] ||= []
      offsets[color].push m.offset(color)[0] + processed_characters
      offsets['clear'].push m.offset(color)[1] + processed_characters
    end

    processed_characters += m.size
    m = regexp.match(m.post_match)
  end
  offsets
end

Hilight::Pattern.define_method(:transform) do |input|
  m = regexp.match input
  output = []

  while m
    output.push m.pre_match unless m.pre_match.empty?

    m.named_captures.each do |color, string|
      output.push Term::ANSIColor.color color, string if string
    end

    post_match = m.post_match
    m = regexp.match(m.post_match)

    output.push post_match unless m
  end

  output
end


# offsets = test_pattern.offsets(test_string)
# puts offsets

require 'pry'

puts test_pattern.transform test_string

binding.pry


# if cmd.any?
#   filters.exec cmd.join(' ')
# else
#   $stdout << default.transform($stdin.readline) until $stdin.eof?
# end
